<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - hogan-3.0.1.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>hogan-3.0.1.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.24</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">733</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">117.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.93</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */



var Hogan = {};

(function (Hogan) {
  Hogan.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || &#039;&#039;;
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.buf = &#039;&#039;;
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return &#039;&#039;; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we&#039;ve instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance &amp;&amp; partial.base == template) {
        return partial.instance;
      }

      if (typeof template == &#039;string&#039;) {
        if (!this.c) {
          throw new Error(&quot;No compiler available.&quot;);
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (!partials.stackText) partials.stackText = {};
        for (key in partial.subs) {
          if (!partials.stackText[key]) {
            partials.stackText[key] = (this.activeSub !== undefined &amp;&amp; partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
          }
        }
        template = createSpecializedPartial(template, partial.subs, partial.partials,
          this.stackSubs, this.stackPartials, partials.stackText);
      }
      this.partials[symbol].instance = template;

      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return &#039;&#039;;
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i &lt; tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) &amp;&amp; val.length === 0) {
        return false;
      }

      if (typeof val == &#039;function&#039;) {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted &amp;&amp; pass &amp;&amp; ctx) {
        ctx.push((typeof val == &#039;object&#039;) ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split(&#039;.&#039;),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === &#039;.&#039; &amp;&amp; isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i &lt; names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found != null) {
            cx = val;
            val = found;
          } else {
            val = &#039;&#039;;
          }
        }
      }

      if (returnFound &amp;&amp; !val) {
        return false;
      }

      if (!returnFound &amp;&amp; typeof val == &#039;function&#039;) {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i &gt;= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val != null) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : &quot;&quot;;
      }

      if (!returnFound &amp;&amp; typeof val == &#039;function&#039;) {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error(&#039;Lambda features disabled.&#039;);
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: function(s) { this.buf += s; },

    fl: function() { var r = this.buf; this.buf = &#039;&#039;; return r; },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result == &#039;function&#039;) {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub &amp;&amp; this.subsText &amp;&amp; this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result == &#039;function&#039;) {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }

  };

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val, checkVal;

    if (scope &amp;&amp; typeof scope == &#039;object&#039;) {

      if (scope[key] != null) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet &amp;&amp; scope.get &amp;&amp; typeof scope.get == &#039;function&#039;) {
        val = scope.get(key);
      }
    }

    return val;
  }

  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
    function PartialTemplate() {};
    PartialTemplate.prototype = instance;
    function Substitutions() {};
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.buf = &#039;&#039;;

    stackSubs = stackSubs || {};
    partial.stackSubs = stackSubs;
    partial.subsText = stackText;
    for (key in subs) {
      if (!stackSubs[key]) stackSubs[key] = subs[key];
    }
    for (key in stackSubs) {
      partial.subs[key] = stackSubs[key];
    }

    stackPartials = stackPartials || {};
    partial.stackPartials = stackPartials;
    for (key in partials) {
      if (!stackPartials[key]) stackPartials[key] = partials[key];
    }
    for (key in stackPartials) {
      partial.partials[key] = stackPartials[key];
    }

    return partial;
  }

  var rAmp = /&amp;/g,
      rLt = /&lt;/g,
      rGt = /&gt;/g,
      rApos = /\&#039;/g,
      rQuot = /\&quot;/g,
      hChars = /[&amp;&lt;&gt;\&quot;\&#039;]/;

  function coerceToString(val) {
    return String((val === null || val === undefined) ? &#039;&#039; : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, &#039;&amp;amp;&#039;)
        .replace(rLt, &#039;&amp;lt;&#039;)
        .replace(rGt, &#039;&amp;gt;&#039;)
        .replace(rApos, &#039;&amp;#39;&#039;)
        .replace(rQuot, &#039;&amp;quot;&#039;) :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === &#039;[object Array]&#039;;
  };

})(typeof exports !== &#039;undefined&#039; ? exports : Hogan);



(function (Hogan) {
  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rQuot = /\&quot;/g,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g;

  Hogan.tags = {
    &#039;#&#039;: 1, &#039;^&#039;: 2, &#039;&lt;&#039;: 3, &#039;$&#039;: 4,
    &#039;/&#039;: 5, &#039;!&#039;: 6, &#039;&gt;&#039;: 7, &#039;=&#039;: 8, &#039;_v&#039;: 9,
    &#039;{&#039;: 10, &#039;&amp;&#039;: 11, &#039;_t&#039;: 12
  };

  Hogan.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = &#039;&#039;,
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = &#039;{{&#039;,
        ctag = &#039;}}&#039;;

    function addBuf() {
      if (buf.length &gt; 0) {
        tokens.push({tag: &#039;_t&#039;, text: new String(buf)});
        buf = &#039;&#039;;
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j &lt; tokens.length; j++) {
        isAllWhitespace =
          (Hogan.tags[tokens[j].tag] &lt; Hogan.tags[&#039;_v&#039;]) ||
          (tokens[j].tag == &#039;_t&#039; &amp;&amp; tokens[j].text.match(rIsWhitespace) === null);
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag &amp;&amp; lineIsWhitespace()) {
        for (var j = lineStart, next; j &lt; tokens.length; j++) {
          if (tokens[j].text) {
            if ((next = tokens[j+1]) &amp;&amp; next.tag == &#039;&gt;&#039;) {
              // set indent to token value
              next.indent = tokens[j].text.toString()
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:&#039;\n&#039;});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = &#039;=&#039; + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf(&#039;=&#039;, index) + 1, closeIndex)
          ).split(&#039; &#039;);

      otag = delimiters[0];
      ctag = delimiters[delimiters.length - 1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(&#039; &#039;);
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i &lt; len; i++) {
      if (state == IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) == &#039;\n&#039;) {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state == IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = Hogan.tags[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : &#039;_v&#039;;
        if (tagType == &#039;=&#039;) {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType == &#039;/&#039;) ? seenTag - otag.length : i + ctag.length});
          buf = &#039;&#039;;
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType == &#039;{&#039;) {
            if (ctag == &#039;}}&#039;) {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);

    return tokens;
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === &#039;}&#039;) {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, &#039;&#039;);
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) != tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i &lt; l; i++) {
      if (text.charAt(index + i) != tag.charAt(i)) {
        return false;
      }
    }

    return true;
  }

  // the tags allowed inside super templates
  var allowedInSuper = {&#039;_t&#039;: true, &#039;\n&#039;: true, &#039;$&#039;: true, &#039;/&#039;: true};

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        tail = null,
        token = null;

    tail = stack[stack.length - 1];

    while (tokens.length &gt; 0) {
      token = tokens.shift();

      if (tail &amp;&amp; tail.tag == &#039;&lt;&#039; &amp;&amp; !(token.tag in allowedInSuper)) {
        throw new Error(&#039;Illegal content in &lt; super tag.&#039;);
      }

      if (Hogan.tags[token.tag] &lt;= Hogan.tags[&#039;$&#039;] || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
      } else if (token.tag == &#039;/&#039;) {
        if (stack.length === 0) {
          throw new Error(&#039;Closing tag without opener: /&#039; + token.n);
        }
        opener = stack.pop();
        if (token.n != opener.n &amp;&amp; !isCloser(token.n, opener.n, customTags)) {
          throw new Error(&#039;Nesting error: &#039; + opener.n + &#039; vs. &#039; + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else if (token.tag == &#039;\n&#039;) {
        token.last = (tokens.length == 0) || (tokens[0].tag == &#039;\n&#039;);
      }

      instructions.push(token);
    }

    if (stack.length &gt; 0) {
      throw new Error(&#039;missing closing tag: &#039; + stack.pop().n);
    }

    return instructions;
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i &lt; l; i++) {
      if (tags[i].o == token.n) {
        token.tag = &#039;#&#039;;
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i &lt; l; i++) {
      if (tags[i].c == close &amp;&amp; tags[i].o == open) {
        return true;
      }
    }
  }

  function stringifySubstitutions(obj) {
    var items = [];
    for (var key in obj) {
      items.push(&#039;&quot;&#039; + esc(key) + &#039;&quot;: function(c,p,t,i) {&#039; + obj[key] + &#039;}&#039;);
    }
    return &quot;{ &quot; + items.join(&quot;,&quot;) + &quot; }&quot;;
  }

  function stringifyPartials(codeObj) {
    var partials = [];
    for (var key in codeObj.partials) {
      partials.push(&#039;&quot;&#039; + esc(key) + &#039;&quot;:{name:&quot;&#039; + esc(codeObj.partials[key].name) + &#039;&quot;, &#039; + stringifyPartials(codeObj.partials[key]) + &quot;}&quot;);
    }
    return &quot;partials: {&quot; + partials.join(&quot;,&quot;) + &quot;}, subs: &quot; + stringifySubstitutions(codeObj.subs);
  }

  Hogan.stringify = function(codeObj, text, options) {
    return &quot;{code: function (c,p,i) { &quot; + Hogan.wrapMain(codeObj.code) + &quot; },&quot; + stringifyPartials(codeObj) +  &quot;}&quot;;
  }

  var serialNo = 0;
  Hogan.generate = function(tree, text, options) {
    serialNo = 0;
    var context = { code: &#039;&#039;, subs: {}, partials: {} };
    Hogan.walk(tree, context);

    if (options.asString) {
      return this.stringify(context, text, options);
    }

    return this.makeTemplate(context, text, options);
  }

  Hogan.wrapMain = function(code) {
    return &#039;var t=this;t.b(i=i||&quot;&quot;);&#039; + code + &#039;return t.fl();&#039;;
  }

  Hogan.template = Hogan.Template;

  Hogan.makeTemplate = function(codeObj, text, options) {
    var template = this.makePartials(codeObj);
    template.code = new Function(&#039;c&#039;, &#039;p&#039;, &#039;i&#039;, this.wrapMain(codeObj.code));
    return new this.template(template, text, this, options);
  }

  Hogan.makePartials = function(codeObj) {
    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
    for (key in template.partials) {
      template.partials[key] = this.makePartials(template.partials[key]);
    }
    for (key in codeObj.subs) {
      template.subs[key] = new Function(&#039;c&#039;, &#039;p&#039;, &#039;t&#039;, &#039;i&#039;, codeObj.subs[key]);
    }
    return template;
  }

  function esc(s) {
    return s.replace(rSlash, &#039;\\\\&#039;)
            .replace(rQuot, &#039;\\\&quot;&#039;)
            .replace(rNewline, &#039;\\n&#039;)
            .replace(rCr, &#039;\\r&#039;);
  }

  function chooseMethod(s) {
    return (~s.indexOf(&#039;.&#039;)) ? &#039;d&#039; : &#039;f&#039;;
  }

  function createPartial(node, context) {
    var prefix = &quot;&lt;&quot; + (context.prefix || &quot;&quot;);
    var sym = prefix + node.n + serialNo++;
    context.partials[sym] = {name: node.n, partials: {}};
    context.code += &#039;t.b(t.rp(&quot;&#039; +  esc(sym) + &#039;&quot;,c,p,&quot;&#039; + (node.indent || &#039;&#039;) + &#039;&quot;));&#039;;
    return sym;
  }

  Hogan.codegen = {
    &#039;#&#039;: function(node, context) {
      context.code += &#039;if(t.s(t.&#039; + chooseMethod(node.n) + &#039;(&quot;&#039; + esc(node.n) + &#039;&quot;,c,p,1),&#039; +
                      &#039;c,p,0,&#039; + node.i + &#039;,&#039; + node.end + &#039;,&quot;&#039; + node.otag + &quot; &quot; + node.ctag + &#039;&quot;)){&#039; +
                      &#039;t.rs(c,p,&#039; + &#039;function(c,p,t){&#039;;
      Hogan.walk(node.nodes, context);
      context.code += &#039;});c.pop();}&#039;;
    },

    &#039;^&#039;: function(node, context) {
      context.code += &#039;if(!t.s(t.&#039; + chooseMethod(node.n) + &#039;(&quot;&#039; + esc(node.n) + &#039;&quot;,c,p,1),c,p,1,0,0,&quot;&quot;)){&#039;;
      Hogan.walk(node.nodes, context);
      context.code += &#039;};&#039;;
    },

    &#039;&gt;&#039;: createPartial,
    &#039;&lt;&#039;: function(node, context) {
      var ctx = {partials: {}, code: &#039;&#039;, subs: {}, inPartial: true};
      Hogan.walk(node.nodes, ctx);
      var template = context.partials[createPartial(node, context)];
      template.subs = ctx.subs;
      template.partials = ctx.partials;
    },

    &#039;$&#039;: function(node, context) {
      var ctx = {subs: {}, code: &#039;&#039;, partials: context.partials, prefix: node.n};
      Hogan.walk(node.nodes, ctx);
      context.subs[node.n] = ctx.code;
      if (!context.inPartial) {
        context.code += &#039;t.sub(&quot;&#039; + esc(node.n) + &#039;&quot;,c,p,i);&#039;;
      }
    },

    &#039;\n&#039;: function(node, context) {
      context.code += write(&#039;&quot;\\n&quot;&#039; + (node.last ? &#039;&#039; : &#039; + i&#039;));
    },

    &#039;_v&#039;: function(node, context) {
      context.code += &#039;t.b(t.v(t.&#039; + chooseMethod(node.n) + &#039;(&quot;&#039; + esc(node.n) + &#039;&quot;,c,p,0)));&#039;;
    },

    &#039;_t&#039;: function(node, context) {
      context.code += write(&#039;&quot;&#039; + esc(node.text) + &#039;&quot;&#039;);
    },

    &#039;{&#039;: tripleStache,

    &#039;&amp;&#039;: tripleStache
  }

  function tripleStache(node, context) {
    context.code += &#039;t.b(t.t(t.&#039; + chooseMethod(node.n) + &#039;(&quot;&#039; + esc(node.n) + &#039;&quot;,c,p,0)));&#039;;
  }

  function write(s) {
    return &#039;t.b(&#039; + s + &#039;);&#039;;
  }

  Hogan.walk = function(nodelist, context) {
    var func;
    for (var i = 0, l = nodelist.length; i &lt; l; i++) {
      func = Hogan.codegen[nodelist[i].tag];
      func &amp;&amp; func(nodelist[i], context);
    }
    return context;
  }

  Hogan.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, &#039;&#039;, [], options.sectionTags || []);
  }

  Hogan.cache = {};

  Hogan.cacheKey = function(text, options) {
    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join(&#039;||&#039;);
  }

  Hogan.compile = function(text, options) {
    options = options || {};
    var key = Hogan.cacheKey(text, options);
    var template = this.cache[key];

    if (template) {
      var partials = template.partials;
      for (var name in partials) {
        delete partials[name].instance;
      }
      return template;
    }

    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    return this.cache[key] = template;
  }
})(typeof exports !== &#039;undefined&#039; ? exports : Hogan);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
